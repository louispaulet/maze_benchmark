<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Procedural Infinite City Car Game</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>

<!-- Include p5.js library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.10.0/p5.min.js"></script>

<!-- Game Code -->
<script>
// Global variables
let car;
let tileSize = 50;
let viewRange = 10; // Number of tiles to display around the car

function setup() {
    createCanvas(windowWidth, windowHeight);
    car = new Car();
}

function draw() {
    background(135, 206, 235); // Sky color

    // Handle input
    handleInput();

    translate(width / 2 - car.x, height / 2 - car.y);
    drawCity();
    car.update();
    car.show();
}

// Input handling
function handleInput() {
    if (keyIsDown(UP_ARROW)) {
        car.accelerate(0.2);
    } else if (keyIsDown(DOWN_ARROW)) {
        car.accelerate(-0.2);
    } else {
        car.applyFriction();
    }

    if (keyIsDown(LEFT_ARROW)) {
        car.turn(-0.05);
    } else if (keyIsDown(RIGHT_ARROW)) {
        car.turn(0.05);
    }
}

// Car class
class Car {
    constructor() {
        this.x = 0;
        this.y = 0;
        this.angle = 0;
        this.speed = 0;
        this.maxSpeed = 5;
    }

    update() {
        this.x += this.speed * cos(this.angle);
        this.y += this.speed * sin(this.angle);
    }

    show() {
        push();
        translate(this.x, this.y);
        rotate(this.angle);
        noStroke();
        fill(255, 0, 0);
        rectMode(CENTER);
        rect(0, 0, 30, 15, 5);
        fill(0);
        // Wheels
        rect(-10, -8, 5, 5);
        rect(10, -8, 5, 5);
        rect(-10, 8, 5, 5);
        rect(10, 8, 5, 5);
        pop();
    }

    accelerate(amount) {
        this.speed += amount;
        this.speed = constrain(this.speed, -this.maxSpeed, this.maxSpeed);
    }

    applyFriction() {
        this.speed *= 0.95;
        if (abs(this.speed) < 0.05) {
            this.speed = 0;
        }
    }

    turn(angle) {
        if (this.speed !== 0) {
            let direction = this.speed > 0 ? 1 : -1;
            this.angle += angle * direction;
        }
    }
}

// Draw the infinite city
function drawCity() {
    let startX = floor((car.x - viewRange * tileSize) / tileSize) * tileSize;
    let endX = floor((car.x + viewRange * tileSize) / tileSize) * tileSize;
    let startY = floor((car.y - viewRange * tileSize) / tileSize) * tileSize;
    let endY = floor((car.y + viewRange * tileSize) / tileSize) * tileSize;

    for (let x = startX; x <= endX; x += tileSize) {
        for (let y = startY; y <= endY; y += tileSize) {
            let tileType = getTileType(x, y);
            drawTile(x, y, tileType);
        }
    }
}

// Determine the type of tile based on position
function getTileType(x, y) {
    // Generate main roads every 5 tiles
    let mainRoadInterval = 5 * tileSize;
    let sideRoadInterval = 2 * tileSize;

    if (x % mainRoadInterval === 0 || y % mainRoadInterval === 0) {
        return 'mainRoad';
    } else if (x % sideRoadInterval === 0 || y % sideRoadInterval === 0) {
        return 'sideRoad';
    } else {
        // Use noise to determine if it's a building, tree, or grass
        let n = noise(x * 0.001, y * 0.001);
        if (n > 0.7) {
            return 'building';
        } else if (n > 0.5) {
            return 'tree';
        } else {
            return 'grass';
        }
    }
}

// Draw a tile at a given position based on its type
function drawTile(x, y, type) {
    push();
    translate(x, y);

    if (type === 'mainRoad') {
        // Draw main road
        fill(60);
        rect(0, 0, tileSize, tileSize);
        // Road markings
        stroke(255, 255, 0);
        strokeWeight(2);
        if (x % (5 * tileSize) === 0) {
            // Vertical road
            line(tileSize / 2, 0, tileSize / 2, tileSize);
        } else {
            // Horizontal road
            line(0, tileSize / 2, tileSize, tileSize / 2);
        }
        noStroke();
    } else if (type === 'sideRoad') {
        // Draw side road
        fill(80);
        rect(0, 0, tileSize, tileSize);
    } else if (type === 'building') {
        // Draw building
        fill(169, 169, 169);
        rect(0, 0, tileSize, tileSize);
        // Add windows
        fill(255, 215, 0);
        let windows = floor(random(2, 5));
        for (let i = 0; i < windows; i++) {
            for (let j = 0; j < windows; j++) {
                rect(5 + i * 10, 5 + j * 10, 5, 5);
            }
        }
    } else if (type === 'tree') {
        // Draw tree
        fill(34, 139, 34);
        ellipse(tileSize / 2, tileSize / 2, tileSize / 1.5, tileSize / 1.5);
        fill(139, 69, 19);
        rect(tileSize / 2 - 5, tileSize / 2, 10, tileSize / 2);
    } else {
        // Draw grass
        fill(34, 139, 34);
        rect(0, 0, tileSize, tileSize);
    }

    pop();
}

// Handle window resizing
function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
}
</script>

</body>
</html>
